# -*- coding: utf-8 -*-
"""AnÃ¡lise logÃ­stica agroindustrial

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11sxg-MAp-Tsw7bacORQw0N9QuOyqbTwl
"""

!pip install streamlit streamlit-folium pyngrok pandas plotly folium
import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
import folium
from folium.plugins import MarkerCluster
from streamlit_folium import st_folium

st.title("ğŸšš AnÃ¡lise LogÃ­stica Agroindustrial")

def simular_entregas(n=100):
    cidades = {
        "Recife": (-8.0476, -34.8770),
        "Caruaru": (-8.2846, -35.9699),
        "Petrolina": (-9.3891, -40.5027),
        "Garanhuns": (-8.8824, -36.4962),
        "Olinda": (-7.9998, -34.8450),
        "Paulista": (-7.9408, -34.8731),
        "Goiana": (-7.5606, -35.0023)
    }
    np.random.seed(42)
    dados = []
    for i in range(n):
        origem = "Recife"
        destino = np.random.choice(list(cidades.keys()))
        if destino == origem:
            destino = "Olinda"
        lat, lon = cidades[destino]
        data_saida = pd.to_datetime("2025-07-01") + pd.to_timedelta(np.random.randint(0, 15), unit="D")
        atraso = np.random.choice([0, 1, 2], p=[0.7, 0.2, 0.1])
        tempo_transporte = np.random.randint(1, 4)
        data_entrega = data_saida + pd.to_timedelta(tempo_transporte + atraso, unit="D")
        distancia = round(np.random.uniform(50, 800), 1)
        dados.append({
            "id_entrega": f"E{i+1:03}",
            "origem": origem,
            "destino": destino,
            "data_saida": data_saida,
            "data_entrega": data_entrega,
            "tempo_entrega": (data_entrega - data_saida).days,
            "atraso_dias": atraso,
            "distancia_km": distancia,
            "lat_destino": lat,
            "lon_destino": lon
        })
    return pd.DataFrame(dados)

uploaded_file = st.file_uploader("ğŸ“‚ FaÃ§a upload do arquivo CSV de entregas", type=["csv"])

if uploaded_file:
    df = pd.read_csv(uploaded_file, parse_dates=["data_saida", "data_entrega"])
    st.success("Arquivo carregado com sucesso!")
else:
    st.info("Nenhum arquivo carregado. Usando dados simulados.")
    df = simular_entregas()

st.subheader("ğŸ“‹ Dados de Entregas")
st.dataframe(df)

st.subheader("â±ï¸ Tempo de Entrega por Cidade")
fig_box = px.box(df, x="destino", y="tempo_entrega", points="all", color="destino",
                 labels={"tempo_entrega": "Tempo (dias)", "destino": "Cidade"})
st.plotly_chart(fig_box, use_container_width=True)

st.subheader("ğŸš¨ Total de Atrasos por Cidade")
atrasos = df.groupby("destino")["atraso_dias"].sum().reset_index()
fig_bar = px.bar(atrasos, x="destino", y="atraso_dias", color="atraso_dias",
                 labels={"atraso_dias": "Dias de Atraso", "destino": "Cidade"})
st.plotly_chart(fig_bar, use_container_width=True)

st.subheader("ğŸ—ºï¸ Mapa Interativo das Entregas")
m = folium.Map(location=[-8.0476, -34.8770], zoom_start=7)
cluster = MarkerCluster().add_to(m)
for _, row in df.iterrows():
    folium.Marker(
        location=[row["lat_destino"], row["lon_destino"]],
        popup=(f"Entrega: {row['id_entrega']}<br>"
               f"Destino: {row['destino']}<br>"
               f"Tempo entrega: {row['tempo_entrega']} dias<br>"
               f"Atraso: {row['atraso_dias']} dia(s)"),
        icon=folium.Icon(color="blue", icon="truck", prefix="fa")
    ).add_to(cluster)

st_folium(m, width=700, height=450)

st.subheader("ğŸ“„ RelatÃ³rio Resumido por Cidade")
relatorio = df.groupby("destino").agg({
    "tempo_entrega": ["mean", "max", "min"],
    "atraso_dias": "sum",
    "id_entrega": "count"
}).reset_index()
relatorio.columns = ["Cidade", "Tempo MÃ©dio", "Tempo MÃ¡ximo", "Tempo MÃ­nimo", "Total Atrasos", "Quantidade Entregas"]
relatorio["Tempo MÃ©dio"] = relatorio["Tempo MÃ©dio"].round(2)
relatorio["Tempo MÃ¡ximo"] = relatorio["Tempo MÃ¡ximo"].astype(int)
relatorio["Tempo MÃ­nimo"] = relatorio["Tempo MÃ­nimo"].astype(int)

st.dataframe(relatorio)

media_total = df["tempo_entrega"].mean()
perc_atraso = (df[df["atraso_dias"] > 0].shape[0] / len(df)) * 100
top_atrasos = relatorio[["Cidade", "Total Atrasos"]].sort_values(by="Total Atrasos", ascending=False).head(3)

st.subheader("âœ… ConclusÃ£o")
st.markdown(
    f"- Tempo mÃ©dio geral de entrega: **{media_total:.2f} dias**  \n"
    f"- Entregas com atraso: **{perc_atraso:.1f}%**  \n"
    f"- Cidades com mais atrasos:  \n"
    f"{top_atrasos.to_markdown(index=False)}"
)

"""# ğŸ›³ï¸ Mini-Projeto Titanic: ClassificaÃ§Ã£o de SobrevivÃªncia

Neste notebook, vamos prever a sobrevivÃªncia de passageiros do Titanic usando:
- RegressÃ£o LogÃ­stica
- Ãrvore de DecisÃ£o
- Random Forest
- KNN

Ao final, vamos comparar os modelos e analisar a importÃ¢ncia das variÃ¡veis.

## âœ… ConclusÃ£o

- O Random Forest teve a melhor performance geral, seguido por...
- Ã‰ possÃ­vel melhorar cada modelo ajustando hiperparÃ¢metros.
- PrÃ³ximos passos: testar mais features, normalizaÃ§Ã£o de dados, cross-validation.

ğŸš€ **Projeto pronto para portfÃ³lio!**

"""